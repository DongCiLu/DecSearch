\section{Path Online Searching}
\label{path}

Online traversal algorithms such as BFS/Dijkstra require to exam $O(n)$ number of vertices in order to find the point-to-point shortest path for any two vertices, they are too expensive for large-scale complex networks. The main focus of the research body of online search algorithm is to achieve lower number of visited vertices for each query.

\subsection{A* Search}

Classical A* search has been used in Artificial Intelligence to find a solution in a huge search space by only searching a small subspace. The reason A* search avoid large number of visited vertices is that it uses estimates on distances to the destination to guide vertex selection in a search. Feasible distance estimates such as Euclidean distance usually do not exist for complex networks. So preprocessing is required to generate such distance estimates before online searching. Suppose the estimates from each vertex to target vertex following a function $\pi$ called a potential function, then the reduced cost of an edge can be defined as following:

\[
    l_{\pi}(v,w) = l_G(v,w) - \pi(v) + \pi(w)
\]

where the $l_G(v,w)$ is the original edge cost of the network. We say $\pi$ is feasible if $l_{\pi}$ is nonnegative for all edges. Only when $\pi$ is feasible, we can use A* search to find the exact shortest path. Due to this constraint, when using landmark based preprocessing, only the lower bound of triangle inequality can be used as the distance estimates \cite{Goldberg:2005:CSP:1070432.1070455}. Since the $max_{l \in L}|d_G(s,l)-d_G(l,t)|$ was used as a feasible potential function, the choice of landmark set has a large compact on the performance of the algorithm in terms of numbers of vertices being visited.

Note that Although A* search which can significantly reduce the number of vertices visited, it still visit a relatively large number of vertices before finding a shortest path. For example, A* search require to access an average of 20K vertices in a graph of 4 million vertices for each point-to-point shortest path query \cite{Potamias:2009:FSP:1645953.1646063}.    

\subsection{Decentralized Search}

J. Kleinberg studied the fundamental reason in small world experiments, why people find the path via a very simple "greedy" heuristic: each person forwards the message to a neighbor who is closest to the target \cite{Kleinberg:2000p5066}. Such "greedy" heuristic was called decentralized search in the paper, since only local information was required to forward the parcel. It turns out that only some of small world networks have such property that will allow efficient navigation through decentralized search. In decentralized search, landmark based preprocessing is used to provide knowledge of distance between vertices, and the algorithm use it to guide the searching. The quality of the path found by decentralized search, that is, the number of visited vertices, depends on the quality of this distance information, more accurate distance information can lead to shorter path being found. 

One characteristic of decentralized search is that the algorithm does not need to maintain a priority queue, so fewer memory overhead is required for each searching which allow more queries to be running at the same time. Further more, if paths to landmarks are stored instead of only distances, then the number of visited vertices for any query of decentralized search is bounded by two times of diameter of the graph. Considering that most complex networks have relatively short diameter, decentralized algorithm has much smaller overhead than other online searchings.

\subsection{Subgraph BFS/Dijkstra Traversal}

Although online BFS/Dijkstra traversals are extremely expensive in large-scale complex networks, several algorithms have been proposed to use them in a much smaller subgraph generated from the original graph.

Instead of only storing distance to each landmark as labels, Tretyakov et al. store shortest path to each landmark, which is called sketch of a vertex \cite{tretyakov2011fast}. When query about the shortest path between each pair, sketches of two vertices are pulled, and they perform a BFS on the subgraph induced by the union of two sketches, to find the shortest path on this subgraph and use it as the approximation of the shortest path of two vertices. Gubichev et al. adopt a very similar way, they use bidirectional BFS to speed up the algorithm and returning a list of paths in increasing length order \cite{Gubichev:2010:FAE:1871437.1871503}. 
